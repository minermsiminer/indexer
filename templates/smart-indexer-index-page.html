<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Web Application Indexer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --accent-color: #3b82f6;
            --hover-color: #f1f5f9;
            --success-color: #10b981;
            --error-color: #ef4444;
        }

        [data-theme="dark"] {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --border-color: #334155;
            --accent-color: #60a5fa;
            --hover-color: #334155;
        }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }

        .card {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-color);
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: #2563eb;
        }

        .sort-indicator {
            display: inline-block;
            margin-left: 4px;
            opacity: 0.5;
        }

        .sort-indicator.active {
            opacity: 1;
        }

        .tag-badge {
            background-color: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 12px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .tag-badge:hover {
            opacity: 0.8;
        }

        .tag-badge.active {
            background-color: var(--success-color);
        }

        .processing {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .thumbnail {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s;
        }

        .thumbnail:hover {
            transform: scale(1.05);
        }

        .thumbnail img {
            width: 100%;
            height: 200px;
            object-fit: cover;
            transition: opacity 0.5s ease-in-out;
        }

        .thumbnail img.fade-in {
            opacity: 0;
            animation: fadeIn 0.5s ease-in-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .favourite-star {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: transparent;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
        }

        .favourite-star i {
            color: #fbbf24;
            transition: color 0.2s;
            font-size: 20px;
        }

        .favourite-star.favourited i {
            color: #fbbf24 !important;
        }

        .missing-deps-corner {
            position: absolute;
            top: 0;
            right: 0;
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 30px 30px 0;
            border-color: transparent var(--error-color) transparent transparent;
        }

        .editable-description {
            cursor: pointer;
            min-height: 24px;
        }

        .editable-description:hover {
            background-color: var(--hover-color);
            border-radius: 4px;
        }

        .description-input {
            width: 100%;
            padding: 4px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
        }

        .folder-group {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 16px;
            overflow: hidden;
        }

        .folder-header {
            background-color: var(--bg-secondary);
            padding: 12px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .folder-header:hover {
            background-color: var(--hover-color);
        }

        .folder-content {
            padding: 16px;
        }

        .collapsed .folder-content {
            display: none;
        }

        .table-container {
            overflow-x: auto;
        }

        .table-container table {
            min-width: 100%;
            table-layout: fixed;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .launch-btn {
            background-color: var(--success-color);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            font-size: 14px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .delete-btn {
            background-color: var(--error-color);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }

        .edit-btn {
            background-color: var(--accent-color);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }

        .edit-btn:hover {
            background-color: #2563eb;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: var(--border-color);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: var(--accent-color);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body data-theme="light" class="min-h-screen">
    <div class="container mx-auto px-4 py-8" style="max-width: 90%;">
        <!-- Header -->
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-2xl font-bold">Smart Web Application Indexer</h1>
            <div class="flex items-center gap-3">
                <button id="theme-toggle" class="px-3 py-1.5 bg-gray-200 dark:bg-gray-700 rounded-lg flex items-center gap-2 text-sm">
                    <i data-lucide="moon" class="w-3 h-3"></i>
                    <span class="text-black dark:text-black">Dark Mode</span>
                </button>
            </div>
        </div>

        <!-- Scan Form -->
        <div class="card rounded-lg p-4 mb-4">
            <h2 class="text-lg font-semibold mb-3">Scan Folder</h2>
            <form action="/scan" method="post" enctype="multipart/form-data" class="flex gap-3">
                <input type="text" name="folder_path" class="flex-1 px-3 py-1.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm" placeholder="/path/to/folder" required>
                <button type="submit" class="px-4 py-1.5 btn-primary rounded-lg font-medium text-sm">Scan Folder</button>
            </form>
        </div>

        <!-- Scanning Status -->
        <div id="scanning-status-container" class="bg-green-100 dark:bg-green-900 border-l-4 border-green-500 text-green-700 dark:text-green-300 p-3 mb-4 processing hidden">
            <div class="flex items-center gap-2 mb-2">
                <i data-lucide="search" class="w-3 h-3 animate-spin"></i>
                <p class="font-bold text-sm">Scanning folder...</p>
            </div>
            <div id="scanning-status" class="mb-2">
                <p id="scanning-text" class="text-sm">Phase: <span id="scanning-phase">Initializing scan...</span></p>
                <p id="scanning-details" class="text-xs opacity-75"></p>
            </div>
            <div class="progress-bar mt-2">
                <div class="progress-fill" id="scanning-progress-fill" style="width: 0%"></div>
            </div>
            <!-- Error Summary -->
            <div id="scanning-error-summary" class="mt-2 text-xs text-red-600 dark:text-red-400 hidden">
                <p>Recent errors: <span id="scanning-error-count" class="font-medium"></span></p>
            </div>
        </div>

        <!-- Processing Status -->
        {% if is_processing %}
        <div class="bg-blue-100 dark:bg-blue-900 border-l-4 border-blue-500 text-blue-700 dark:text-blue-300 p-3 mb-4 processing">
            <div class="flex items-center gap-2 mb-2">
                <i data-lucide="loader" class="w-3 h-3 animate-spin"></i>
                <p class="font-bold text-sm">Processing thumbnails...</p>
            </div>
            <div id="processing-status" class="mb-2">
                <p id="processing-text" class="text-sm">Completed: {{ processing_completed }} / {{ processing_total }}</p>
                <p id="processing-details" class="text-xs opacity-75"></p>
            </div>
            <div class="progress-bar mt-2">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
            <!-- Current Item Status -->
            <div id="current-item-status" class="mt-2 text-xs opacity-75 hidden">
                <p>Currently processing: <span id="current-item-name" class="font-medium"></span></p>
            </div>
            <!-- Error Summary -->
            <div id="error-summary" class="mt-2 text-xs text-red-600 dark:text-red-400 hidden">
                <p>Recent errors: <span id="error-count" class="font-medium"></span></p>
            </div>
        </div>
        {% endif %}

        <!-- Controls Bar -->
        <div class="card rounded-lg p-3 mb-4">
            <div class="flex flex-wrap items-center justify-between gap-3">
                <!-- Left side controls -->
                <div class="flex items-center gap-3">
                    <!-- View Toggle -->
                    <div class="flex items-center gap-2">
                        <button id="view-toggle" class="px-3 py-1.5 bg-blue-500 text-white rounded-lg flex items-center gap-2 text-sm">
                            <i data-lucide="grid" class="w-3 h-3"></i>
                            <span>Grid View</span>
                        </button>
                    </div>

                    <!-- Folders Toggle -->
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" id="folders-toggle" class="w-3 h-3 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500 dark:focus:ring-blue-600 dark:ring-offset-gray-800 focus:ring-2 dark:bg-gray-700 dark:border-gray-600">
                        <span class="text-xs font-medium">Show Folders</span>
                    </label>

                    <!-- Date Range Filter -->
                    <div class="flex items-center gap-2">
                        <label class="text-xs font-medium">Date Range:</label>
                        <input type="date" id="date-from" class="px-2 py-1.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm">
                        <span class="text-xs">to</span>
                        <input type="date" id="date-to" class="px-2 py-1.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm">
                        <button id="apply-date-filter" class="px-3 py-1.5 bg-blue-500 text-white rounded-lg hover:bg-blue-600 text-sm">Apply</button>
                        <button id="clear-date-filter" class="px-3 py-1.5 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-400 dark:hover:bg-gray-500 text-sm">Clear</button>
                    </div>
                </div>

                <!-- Right side - Action buttons -->
                <div class="flex items-center gap-3">
                    <!-- Fix Thumbnails Button -->
                    <button id="fix-thumbnails" class="px-3 py-1.5 bg-orange-500 text-white rounded-lg hover:bg-orange-600 flex items-center gap-2 text-sm">
                        <i data-lucide="image" class="w-3 h-3"></i>
                        <span>Fix Thumbnails</span>
                    </button>

                    <!-- Clean Apps Button -->
                    <button id="clean-apps" onclick="cleanApps()" class="px-3 py-1.5 bg-purple-600 text-white rounded-lg hover:bg-purple-700 flex items-center gap-2 text-sm">
                        <span>üßπ</span>
                        <span>Clean Apps</span>
                    </button>

                    <!-- Purge Database Button -->
                    <button id="purge-database" class="px-3 py-1.5 bg-red-600 text-white rounded-lg hover:bg-red-700 flex items-center gap-2 text-sm">
                        <i data-lucide="trash-2" class="w-3 h-3"></i>
                        <span>Purge Database</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Search & Filter Bar -->
        <div class="card rounded-lg p-3 mb-4">
            <div class="flex flex-wrap items-center justify-between gap-3">
                <!-- Left side - Search and filters -->
                <div class="flex items-center gap-3">
                    <!-- Search Input -->
                    <div class="flex-1 min-w-[48rem]">
                        <input type="text" id="search-input" class="w-full px-3 py-1.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm" placeholder="Search by name, description, or tags...">
                    </div>

                    <!-- Category Filter -->
                    <div class="min-w-36">
                        <select id="category-filter" class="w-full px-3 py-1.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm">
                            <option value="">All Categories</option>
                            <option value="python_app">Python Apps</option>
                            <option value="standalone_html">HTML Files</option>
                            <option value="favourite">Favourites</option>
                        </select>
                    </div>

                    <!-- Date Sorting -->
                    <div class="min-w-36">
                        <select id="date-sort" class="w-full px-3 py-1.5 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-800 text-gray-900 dark:text-white text-sm">
                            <option value="">No Date Sorting</option>
                            <option value="created_asc">Date Created (Oldest First)</option>
                            <option value="created_desc" selected>Date Created (Newest First)</option>
                            <option value="modified_asc">Date Modified (Oldest First)</option>
                            <option value="modified_desc">Date Modified (Newest First)</option>
                        </select>
                    </div>
                </div>

                <!-- Right side - Item Counter -->
                <div id="item-counter" class="text-sm text-orange-600 dark:text-orange-400">
                    Total: 0 items
                </div>
            </div>

            <!-- Tag Filter Badges -->
            <div id="tag-filter-container" class="flex flex-wrap gap-2 mt-3">
                <!-- Tags will be populated by JavaScript -->
            </div>
        </div>

        <!-- Content Area -->
        <div id="content-area">
            <!-- Content will be populated by JavaScript -->
        </div>

        <!-- Empty State -->
        <div id="empty-state" class="text-center py-12 hidden">
            <i data-lucide="folder-x" class="w-16 h-16 text-gray-400 mx-auto mb-4"></i>
            <h3 class="text-xl font-semibold text-gray-600 dark:text-gray-400 mb-2">No applications found</h3>
            <p class="text-gray-500 dark:text-gray-500">Scan a folder above to get started with indexing your web applications.</p>
        </div>
    </div>

    <!-- Modals and Overlays -->
    <div id="delete-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden flex items-center justify-center z-50">
        <div class="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full mx-4">
            <h3 class="text-lg font-semibold mb-4">Confirm Deletion</h3>
            <p class="text-gray-600 dark:text-gray-400 mb-6">Are you sure you want to delete this item? This action cannot be undone.</p>
            <div class="flex justify-end gap-4">
                <button id="cancel-delete" class="px-4 py-2 bg-gray-300 dark:bg-gray-600 text-gray-700 dark:text-gray-300 rounded-lg">Cancel</button>
                <button id="confirm-delete" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600">Delete</button>
            </div>
        </div>
    </div>

    <script type="application/json" id="thumbnails-data">
        {{ thumbnails|tojson|safe }}
    </script>

    <script data-processing="{{ 'true' if is_processing else 'false' }}">
        // Global state
        let allItems = JSON.parse(document.getElementById('thumbnails-data').textContent);
        let filteredItems = [...allItems];
        let currentView = 'grid'; // 'grid' or 'table'
        let showFolders = false;
        let sortColumn = 'name';
        let sortDirection = 'asc';
        let activeTags = new Set();
        let collapsedGroups = new Set();
        let searchTimeout;
        let dateSort = '';
        let dateFrom = '';
        let dateTo = '';

        // Selective thumbnail update state
        let lastCompletedCheck = new Date().toISOString();
        let thumbnailUpdateInterval;
        let isPollingActive = false;

        // Cached DOM element references for performance
        const domElements = {
            contentArea: document.getElementById('content-area'),
            emptyState: document.getElementById('empty-state'),
            searchInput: document.getElementById('search-input'),
            categoryFilter: document.getElementById('category-filter'),
            foldersToggle: document.getElementById('folders-toggle'),
            viewToggle: document.getElementById('view-toggle'),
            themeToggle: document.getElementById('theme-toggle'),
            fixThumbnailsBtn: document.getElementById('fix-thumbnails'),
            cleanAppsBtn: document.getElementById('clean-apps'),
            purgeDatabaseBtn: document.getElementById('purge-database'),
            tagFilterContainer: document.getElementById('tag-filter-container'),
            itemCounter: document.getElementById('item-counter'),
            deleteModal: document.getElementById('delete-modal'),
            cancelDeleteBtn: document.getElementById('cancel-delete'),
            confirmDeleteBtn: document.getElementById('confirm-delete'),
            dateSortSelect: document.getElementById('date-sort'),
            dateFromInput: document.getElementById('date-from'),
            dateToInput: document.getElementById('date-to'),
            applyDateFilterBtn: document.getElementById('apply-date-filter'),
            clearDateFilterBtn: document.getElementById('clear-date-filter'),
            // Scanning progress elements
            scanningProgressFill: document.getElementById('scanning-progress-fill'),
            scanningText: document.getElementById('scanning-text'),
            scanningDetails: document.getElementById('scanning-details'),
            scanningErrorSummary: document.getElementById('scanning-error-summary'),
            scanningErrorCount: document.getElementById('scanning-error-count'),
            // Processing progress elements
            progressFill: document.getElementById('progress-fill'),
            processingText: document.getElementById('processing-text'),
            processingDetails: document.getElementById('processing-details'),
            currentItemStatus: document.getElementById('current-item-status'),
            currentItemName: document.getElementById('current-item-name'),
            errorSummary: document.getElementById('error-summary'),
            errorCount: document.getElementById('error-count')
        };

        // Cached image elements map for efficient thumbnail updates
        let imageElementCache = new Map();

        // Throttling for polling operations
        let pollingThrottleTimeout = null;
        const POLLING_THROTTLE_MS = 1000; // Minimum 1 second between polls

        let itemToDelete = null;

        // Image caching function - defined early to be available for onload events
        window.cacheImageElement = function(itemId, imgElement) {
            if (!imageElementCache.has(itemId)) {
                imageElementCache.set(itemId, []);
            }
            const cached = imageElementCache.get(itemId);
            if (!cached.includes(imgElement)) {
                cached.push(imgElement);
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            loadTheme();
            loadTags();
            renderContent();
            updateItemCounter();
            lucide.createIcons();
        });

        // Event listeners
        domElements.searchInput.addEventListener('input', debounce(handleSearch, 300));
        domElements.categoryFilter.addEventListener('change', handleFilterChange);
        domElements.foldersToggle.addEventListener('change', handleFoldersToggle);
        domElements.viewToggle.addEventListener('click', toggleView);
        domElements.themeToggle.addEventListener('click', toggleTheme);
        domElements.fixThumbnailsBtn.addEventListener('click', fixThumbnails);
        domElements.purgeDatabaseBtn.addEventListener('click', purgeDatabase);
        domElements.cancelDeleteBtn.addEventListener('click', () => hideDeleteModal());
        domElements.confirmDeleteBtn.addEventListener('click', confirmDelete);
        domElements.dateSortSelect.addEventListener('change', handleDateSortChange);
        domElements.applyDateFilterBtn.addEventListener('click', applyDateFilter);
        domElements.clearDateFilterBtn.addEventListener('click', clearDateFilter);

        // Scan form submission listener
        const scanForm = document.querySelector('form[action="/scan"]');
        if (scanForm) {
            scanForm.addEventListener('submit', function() {
                // Show scanning status immediately when scan starts
                setTimeout(showScanningStatus, 100);
            });
        }

        // Auto-refresh during processing
        const isProcessing = document.currentScript.getAttribute('data-processing') === 'true';

        // Check for scanning progress on page load
        checkScanningStatus();

        function checkScanningStatus() {
            fetch('/scanning-progress')
                .then(response => response.json())
                .then(data => {
                    if (data.is_scanning) {
                        // Show scanning status and start polling
                        showScanningStatus();
                        startScanningPolling();
                    } else if (isProcessing) {
                        // Start thumbnail processing polling
                        startThumbnailProcessing();
                    } else {
                        // Start selective thumbnail polling immediately if not processing
                        startThumbnailPolling();
                    }
                })
                .catch(error => {
                    console.error('Error checking scanning status:', error);
                    if (isProcessing) {
                        startThumbnailProcessing();
                    } else {
                        startThumbnailPolling();
                    }
                });
        }

        function showScanningStatus() {
            if (domElements.scanningStatusContainer) {
                domElements.scanningStatusContainer.classList.remove('hidden');
            }
        }

        function startScanningPolling() {
            console.log(`[${new Date().toISOString()}] Starting scanning polling`);
            let scanningInterval = 2000; // Start with 2 seconds
            let scanningRetryCount = 0;
            const maxRetries = 5;
            let scanningBackoffMultiplier = 1;

            const scanningIntervalId = setInterval(function() {
                const pollStart = performance.now();
                console.log(`[${new Date().toISOString()}] Scanning poll start`);
                fetch('/scanning-progress')
                    .then(response => response.json())
                    .then(data => {
                        const fetchEnd = performance.now();
                        console.log(`[${new Date().toISOString()}] Scanning fetch completed in ${(fetchEnd - pollStart).toFixed(2)}ms`);
                        scanningRetryCount = 0; // Reset on success
                        scanningBackoffMultiplier = 1; // Reset backoff

                        if (!data.is_scanning) {
                            console.log(`[${new Date().toISOString()}] Scanning complete, clearing interval`);
                            clearInterval(scanningIntervalId);
                            // Hide scanning status when complete
                            hideScanningStatus();
                            // Start thumbnail processing after scanning completes
                            startThumbnailProcessing();
                        } else {
                            // Ensure scanning status is visible
                            showScanningStatus();

                            // Use requestAnimationFrame for DOM updates
                            requestAnimationFrame(() => {
                                const domStart = performance.now();
                                console.log(`[${new Date().toISOString()}] DOM query count check - scanning elements`);

                                // Update scanning progress bar
                                if (domElements.scanningProgressFill) {
                                    domElements.scanningProgressFill.style.width = data.progress_percentage + '%';
                                }

                                // Update scanning text
                                if (domElements.scanningText) {
                                    domElements.scanningText.innerHTML = `Phase: <span id="scanning-phase">${data.current_phase_desc}</span>`;
                                }

                                // Update scanning details
                                if (domElements.scanningDetails) {
                                    let details = `${data.completed} / ${data.total} items processed`;
                                    if (data.queue_size > 0) {
                                        details += ` ‚Ä¢ Queue: ${data.queue_size}`;
                                    }
                                    domElements.scanningDetails.textContent = details;
                                }

                                // Update error summary
                                if (data.recent_errors && data.recent_errors.length > 0 && domElements.scanningErrorSummary && domElements.scanningErrorCount) {
                                    domElements.scanningErrorCount.textContent = `${data.recent_errors.length} error(s)`;
                                    domElements.scanningErrorSummary.classList.remove('hidden');
                                } else if (domElements.scanningErrorSummary) {
                                    domElements.scanningErrorSummary.classList.add('hidden');
                                }
                                const domEnd = performance.now();
                                console.log(`[${new Date().toISOString()}] Scanning DOM updates completed in ${(domEnd - domStart).toFixed(2)}ms`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error(`[${new Date().toISOString()}] Error fetching scanning progress:`, error);
                        scanningRetryCount++;

                        if (scanningRetryCount >= maxRetries) {
                            console.error(`[${new Date().toISOString()}] Max retries reached for scanning polling, stopping`);
                            clearInterval(scanningIntervalId);
                            return;
                        }

                        // Implement backoff: increase interval on errors
                        scanningBackoffMultiplier = Math.min(scanningBackoffMultiplier * 1.5, 10); // Max 10x multiplier
                        const newInterval = scanningInterval * scanningBackoffMultiplier;
                        console.log(`[${new Date().toISOString()}] Backing off scanning polling to ${newInterval}ms`);

                        // Clear current interval and restart with new timing
                        clearInterval(scanningIntervalId);
                        setTimeout(() => startScanningPolling(), newInterval);
                    });
            }, scanningInterval);
        }

        function hideScanningStatus() {
            if (domElements.scanningStatusContainer) {
                domElements.scanningStatusContainer.classList.add('hidden');
            }
        }

        function startThumbnailProcessing() {
            console.log(`[${new Date().toISOString()}] Starting thumbnail processing polling`);
            let processingInterval = 2000; // Start with 2 seconds
            let processingRetryCount = 0;
            const maxRetries = 5;
            let processingBackoffMultiplier = 1;

            const processingIntervalId = setInterval(function() {
                const pollStart = performance.now();
                console.log(`[${new Date().toISOString()}] Thumbnail processing poll start`);
                fetch('/progress')
                    .then(response => response.json())
                    .then(data => {
                        const fetchEnd = performance.now();
                        console.log(`[${new Date().toISOString()}] Thumbnail processing fetch completed in ${(fetchEnd - pollStart).toFixed(2)}ms`);
                        processingRetryCount = 0; // Reset on success
                        processingBackoffMultiplier = 1; // Reset backoff

                        if (!data.is_processing) {
                            console.log(`[${new Date().toISOString()}] Thumbnail processing complete, clearing interval and reloading`);
                            clearInterval(processingIntervalId);
                            // Start selective thumbnail polling when processing is complete
                            startThumbnailPolling();
                            location.reload();
                        } else {
                            // Use requestAnimationFrame for DOM updates
                            requestAnimationFrame(() => {
                                const domStart = performance.now();
                                console.log(`[${new Date().toISOString()}] DOM query count check - processing elements`);

                                // Update progress bar
                                if (domElements.progressFill) {
                                    domElements.progressFill.style.width = data.progress_percentage + '%';
                                }

                                // Update processing text
                                if (domElements.processingText) {
                                    domElements.processingText.textContent = `Completed: ${data.completed} / ${data.total} (${data.progress_percentage}%)`;
                                }

                                // Update processing details
                                if (domElements.processingDetails) {
                                    let details = '';
                                    if (data.processing_rate > 0) {
                                        details += `${data.processing_rate} items/min`;
                                    }
                                    if (data.eta_seconds > 0) {
                                        const etaMinutes = Math.floor(data.eta_seconds / 60);
                                        const etaSeconds = data.eta_seconds % 60;
                                        details += ` ‚Ä¢ ETA: ${etaMinutes}:${etaSeconds.toString().padStart(2, '0')}`;
                                    }
                                    if (data.queue_size > 0) {
                                        details += ` ‚Ä¢ Queue: ${data.queue_size}`;
                                    }
                                    domElements.processingDetails.textContent = details;
                                }

                                // Update current item status
                                if (data.current_item && domElements.currentItemStatus && domElements.currentItemName) {
                                    domElements.currentItemName.textContent = `${data.current_item.name} (${data.current_item.type})`;
                                    domElements.currentItemStatus.classList.remove('hidden');
                                } else if (domElements.currentItemStatus) {
                                    domElements.currentItemStatus.classList.add('hidden');
                                }

                                // Update error summary
                                if (data.recent_errors && data.recent_errors.length > 0 && domElements.errorSummary && domElements.errorCount) {
                                    domElements.errorCount.textContent = `${data.recent_errors.length} error(s)`;
                                    domElements.errorSummary.classList.remove('hidden');
                                } else if (domElements.errorSummary) {
                                    domElements.errorSummary.classList.add('hidden');
                                }

                                // Smart refresh: update only item counter
                                updateItemCounter();

                                // Optimized placeholder image updates: only update cached placeholder images
                                updatePlaceholderImages();

                                // Real-time thumbnail updates: check for completed thumbnails
                                checkForCompletedThumbnails();
                                const domEnd = performance.now();
                                console.log(`[${new Date().toISOString()}] Thumbnail processing DOM updates completed in ${(domEnd - domStart).toFixed(2)}ms`);
                            });
                        }
                    })
                    .catch(error => {
                        console.error(`[${new Date().toISOString()}] Error fetching progress:`, error);
                        processingRetryCount++;

                        if (processingRetryCount >= maxRetries) {
                            console.error(`[${new Date().toISOString()}] Max retries reached for thumbnail processing polling, stopping`);
                            clearInterval(processingIntervalId);
                            return;
                        }

                        // Implement backoff: increase interval on errors
                        processingBackoffMultiplier = Math.min(processingBackoffMultiplier * 1.5, 10); // Max 10x multiplier
                        const newInterval = processingInterval * processingBackoffMultiplier;
                        console.log(`[${new Date().toISOString()}] Backing off thumbnail processing polling to ${newInterval}ms`);

                        // Clear current interval and restart with new timing
                        clearInterval(processingIntervalId);
                        setTimeout(() => startThumbnailProcessing(), newInterval);
                    });
            }, processingInterval);
        }

        function debounce(func, wait) {
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(searchTimeout);
                    func(...args);
                };
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(later, wait);
            };
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme') || 'light';
            document.body.setAttribute('data-theme', savedTheme);
            updateThemeButton(savedTheme);
        }

        function updateThemeButton(theme) {
            const button = domElements.themeToggle;
            const existingIcon = button.querySelector('i, svg');
            if (existingIcon) {
                existingIcon.remove();
            }
            const icon = document.createElement('i');
            icon.setAttribute('data-lucide', theme === 'dark' ? 'sun' : 'moon');
            const span = button.querySelector('span');
            span.textContent = theme === 'dark' ? 'Light Mode' : 'Dark Mode';
            button.insertBefore(icon, span);
            lucide.createIcons();
        }

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.body.setAttribute('data-theme', newTheme);
            localStorage.setItem('theme', newTheme);
            updateThemeButton(newTheme);
        }

        function loadTags() {
            fetch('/api/tags')
                .then(response => response.json())
                .then(data => {
                    renderTagFilters(data);
                })
                .catch(error => console.error('Error loading tags:', error));
        }

        function renderTagFilters(tagsData) {
            domElements.tagFilterContainer.innerHTML = '';
            if (tagsData && tagsData.length > 0) {
                tagsData.forEach(tag => {
                    const badge = document.createElement('span');
                    badge.className = `tag-badge ${activeTags.has(tag.tag) ? 'active' : ''}`;
                    badge.textContent = `${tag.tag} (${tag.usage_count})`;
                    badge.onclick = () => toggleTag(tag.tag);
                    domElements.tagFilterContainer.appendChild(badge);
                });
            }
        }

        function toggleTag(tag) {
            if (activeTags.has(tag)) {
                activeTags.delete(tag);
            } else {
                activeTags.add(tag);
            }
            renderTagFilters();
            handleFilterChange();
        }

        function handleSearch() {
            handleFilterChange();
        }

        function handleFilterChange() {
            const searchTerm = domElements.searchInput.value.toLowerCase();
            const categoryValue = domElements.categoryFilter.value;

            filteredItems = allItems.filter(item => {
                // Search filter
                const matchesSearch = !searchTerm ||
                    item.name.toLowerCase().includes(searchTerm) ||
                    (item.description && item.description.toLowerCase().includes(searchTerm)) ||
                    (item.tags && item.tags.toLowerCase().includes(searchTerm)) ||
                    (item.folder_path && item.folder_path.toLowerCase().includes(searchTerm));

                // Category filter
                let matchesCategory = true;
                if (categoryValue) {
                    if (categoryValue === 'favourite') {
                        matchesCategory = item.is_favourite;
                    } else if (categoryValue === 'python_app') {
                        matchesCategory = item.app_type === 'python_app';
                    } else if (categoryValue === 'standalone_html') {
                        matchesCategory = item.app_type === 'standalone_html';
                    } else {
                        matchesCategory = item.category === categoryValue;
                    }
                }

                // Tag filter
                const matchesTags = activeTags.size === 0 ||
                    (item.tags && activeTags.has(item.tags.split(',')[0]?.trim()));

                // Date range filter
                const matchesDateRange = checkDateRangeFilter(item);

                return matchesSearch && matchesCategory && matchesTags && matchesDateRange;
            });

            // Apply date sorting if selected
            if (dateSort) {
                applyDateSorting();
            }

            renderContent();
            updateItemCounter();
        }

        function handleFoldersToggle() {
            showFolders = domElements.foldersToggle.checked;
            renderContent();
        }

        function toggleView() {
            currentView = currentView === 'grid' ? 'table' : 'grid';
            updateViewButton();
            renderContent();
        }

        function updateViewButton() {
            if (!domElements.viewToggle) return;
            const button = domElements.viewToggle;
            const existingIcon = button.querySelector('i, svg');
            if (existingIcon) {
                existingIcon.remove();
            }
            const icon = document.createElement('i');
            icon.setAttribute('data-lucide', currentView === 'grid' ? 'table' : 'grid');
            const span = button.querySelector('span');
            span.textContent = currentView === 'grid' ? 'Table View' : 'Grid View';
            button.insertBefore(icon, span);
            lucide.createIcons();
        }

        function updateItemCounter() {
            const total = allItems.length;
            const filtered = filteredItems.length;
            if (filtered === total) {
                domElements.itemCounter.textContent = `Total: ${total} items`;
            } else {
                domElements.itemCounter.textContent = `Showing ${filtered} of ${total} items`;
            }
        }

        function renderContent() {
            if (filteredItems.length === 0) {
                domElements.contentArea.innerHTML = '';
                domElements.emptyState.classList.remove('hidden');
                return;
            }

            domElements.emptyState.classList.add('hidden');

            if (currentView === 'grid') {
                renderGridView();
            } else {
                renderTableView();
            }
        }

        function renderGridView() {
            let html = '<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">';

            if (showFolders) {
                const groupedItems = groupItemsByFolder(filteredItems);
                Object.keys(groupedItems).sort().forEach(folder => {
                    const items = groupedItems[folder];
                    const isCollapsed = collapsedGroups.has(folder);

                    html += `
                        <div class="folder-group col-span-full">
                            <div class="folder-header" onclick="toggleFolder('${folder.replace(/'/g, "\\'")}')">
                                <h3 class="font-semibold">${folder}</h3>
                                <i data-lucide="${isCollapsed ? 'chevron-down' : 'chevron-up'}" class="w-4 h-4"></i>
                            </div>
                            <div class="folder-content ${isCollapsed ? 'collapsed' : ''}">
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                    `;

                    items.forEach(item => {
                        html += renderGridItem(item);
                    });

                    html += `
                                </div>
                            </div>
                        </div>
                    `;
                });
            } else {
                filteredItems.forEach(item => {
                    html += renderGridItem(item);
                });
            }

            html += '</div>';
            domElements.contentArea.innerHTML = html;
            lucide.createIcons();
        }

        function renderGridItem(item) {
            const thumbUrl = item.thumb_url || '/static/thumbnails/placeholder.png';
            const typeIcon = item.app_type === 'python_app' ? 'üêç' : 'üìÑ';
            const typeText = item.app_type === 'python_app' ? 'Python' : 'HTML';
            const launchUrl = item.app_type === 'python_app' ? item.html_file_url : item.html_file_url;

            return `
                <div class="thumbnail card p-4">
                    ${!item.dependencies_ok ? '<div class="missing-deps-corner" title="Missing dependencies"></div>' : ''}
                    <img src="${thumbUrl}" alt="${item.name}" data-item-id="${item.id}" onerror="this.src='/static/thumbnails/placeholder.png'" onload="cacheImageElement(${item.id}, this)">
                    <div class="favourite-star ${item.is_favourite ? 'favourited' : ''}" onclick="toggleFavourite(${item.id})" title="${item.is_favourite ? 'Remove from favourites' : 'Add to favourites'}">
                        <i data-lucide="star" class="w-6 h-6 ${item.is_favourite ? 'fill-current' : ''}" style="color: #fbbf24 !important;"></i>
                    </div>
                    <div class="mt-4">
                        <div class="flex items-center justify-between mb-2">
                            <h3 class="font-semibold text-lg">${item.name} <span class="text-sm text-gray-500 dark:text-gray-400">(${item.main_file_path ? item.main_file_path.split('/').pop() : item.html_file ? item.html_file.split('/').pop() : item.python_script ? item.python_script.split('/').pop() : 'unknown'})</span></h3>
                            <span class="text-xs bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded">${typeIcon} ${typeText}</span>
                        </div>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mb-2 line-clamp-2">${item.description || 'No description'}</p>
                        ${item.tags ? `<div class="flex flex-wrap gap-1 mb-4">${renderTags(item.tags)}</div>` : ''}
                        <div class="flex gap-2">
                            <a href="${launchUrl}" target="_blank" class="launch-btn flex-1">
                                <i data-lucide="play" class="w-4 h-4 mr-1"></i>
                                ${item.app_type === 'python_app' ? 'Launch' : 'Open'}
                            </a>
                            <button onclick="editProject('${item.folder_path}')" class="edit-btn">
                                <i data-lucide="edit" class="w-3 h-3"></i>
                            </button>
                            <button onclick="deleteItem(${item.id})" class="delete-btn">
                                <i data-lucide="trash-2" class="w-3 h-3"></i>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        function renderTableView() {
            let html = '<div class="table-container"><table class="w-full border-collapse">';

            // Table header
            html += `
                <thead>
                    <tr class="border-b border-gray-300 dark:border-gray-600">
                        <th class="text-left p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" onclick="sortTable('name')" style="width: 21%;">
                            Name <span class="sort-indicator ${sortColumn === 'name' ? 'active' : ''}" data-column="name">${sortColumn === 'name' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : '‚Üï'}</span>
                        </th>
                        <th class="text-left p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" onclick="sortTable('app_type')" style="width: 6%;">
                            Type <span class="sort-indicator ${sortColumn === 'app_type' ? 'active' : ''}" data-column="app_type">${sortColumn === 'app_type' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : '‚Üï'}</span>
                        </th>
                        <th class="text-left p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-100 dark:hover:bg-gray-700" onclick="sortTable('description')" style="width: 38%;">
                            Description <span class="sort-indicator ${sortColumn === 'description' ? 'active' : ''}" data-column="description">${sortColumn === 'description' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : '‚Üï'}</span>
                        </th>
                        <th class="text-left p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" onclick="sortTable('category')" style="width: 8%;">
                            Category <span class="sort-indicator ${sortColumn === 'category' ? 'active' : ''}" data-column="category">${sortColumn === 'category' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : '‚Üï'}</span>
                        </th>
                        <th class="text-left p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" onclick="sortTable('tags')" style="width: 15%;">
                            Tags <span class="sort-indicator ${sortColumn === 'tags' ? 'active' : ''}" data-column="tags">${sortColumn === 'tags' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : '‚Üï'}</span>
                        </th>
                        <th class="text-left p-3 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" onclick="sortTable('file_size')" style="width: 6%;">
                            Size <span class="sort-indicator ${sortColumn === 'file_size' ? 'active' : ''}" data-column="file_size">${sortColumn === 'file_size' ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : '‚Üï'}</span>
                        </th>
                        <th class="text-left p-3" style="width: 6%;">Actions</th>
                    </tr>
                </thead>
                <tbody>
            `;

            // Sort items
            const sortedItems = [...filteredItems].sort((a, b) => {
                let aVal = a[sortColumn] || '';
                let bVal = b[sortColumn] || '';

                if (sortColumn === 'file_size') {
                    aVal = aVal || 0;
                    bVal = bVal || 0;
                }

                if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
                if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            if (showFolders) {
                const groupedItems = groupItemsByFolder(sortedItems);
                Object.keys(groupedItems).sort().forEach(folder => {
                    const items = groupedItems[folder];
                    const isCollapsed = collapsedGroups.has(folder);

                    html += `
                        <tr class="folder-group border-b border-gray-300 dark:border-gray-600">
                            <td colspan="7" class="p-0">
                                <div class="folder-header" onclick="toggleFolder('${folder.replace(/'/g, "\\'")}')">
                                    <h3 class="font-semibold p-3">${folder} (${items.length} items)</h3>
                                    <i data-lucide="${isCollapsed ? 'chevron-down' : 'chevron-up'}" class="w-4 h-4 mr-3"></i>
                                </div>
                                <div class="folder-content ${isCollapsed ? 'collapsed' : ''}">
                                    <table class="w-full">
                    `;

                    items.forEach(item => {
                        html += renderTableRow(item);
                    });

                    html += `
                                    </table>
                                </div>
                            </td>
                        </tr>
                    `;
                });
            } else {
                sortedItems.forEach(item => {
                    html += renderTableRow(item);
                });
            }

            html += '</tbody></table></div>';
            domElements.contentArea.innerHTML = html;
            lucide.createIcons();
        }

        function renderTableRow(item) {
            const thumbUrl = item.thumb_url || '/static/thumbnails/placeholder.png';
            const typeIcon = item.app_type === 'python_app' ? 'üêç' : 'üìÑ';
            const typeText = item.app_type === 'python_app' ? 'Python' : 'HTML';
            const launchUrl = item.app_type === 'python_app' ? item.html_file_url : item.html_file_url;
            const fileSize = item.file_size ? formatFileSize(item.file_size) : 'N/A';

            return `
                <tr class="border-b border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-800">
                    <td class="p-3">
                        <div class="flex items-center gap-3">
                            <div class="relative">
                                <img src="${thumbUrl}" alt="${item.name}" data-item-id="${item.id}" class="w-12 h-12 object-cover rounded" onerror="this.src='/static/thumbnails/placeholder.png'" onload="cacheImageElement(${item.id}, this)">
                                <div class="favourite-star ${item.is_favourite ? 'favourited' : ''}" onclick="toggleFavourite(${item.id})" title="${item.is_favourite ? 'Remove from favourites' : 'Add to favourites'}" style="position: absolute; top: -4px; right: -4px; width: 20px; height: 20px;">
                                    <i data-lucide="star" class="w-4 h-4 ${item.is_favourite ? 'fill-current' : ''}" style="color: #fbbf24 !important;"></i>
                                </div>
                            </div>
                            <div>
                                <div class="font-semibold">${item.name} <span class="text-sm text-gray-500">(${item.main_file_path ? item.main_file_path.split('/').pop() : item.html_file ? item.html_file.split('/').pop() : item.python_script ? item.python_script.split('/').pop() : 'unknown'})</span></div>
                                <div class="text-xs text-gray-500">${item.folder_path ? item.folder_path.split('/').pop() : ''}</div>
                            </div>
                        </div>
                    </td>
                    <td class="p-3">
                        <span class="text-xs bg-gray-200 dark:bg-gray-700 px-2 py-1 rounded">${typeIcon} ${typeText}</span>
                    </td>
                    <td class="p-3">
                        <div class="editable-description" onclick="editDescription(${item.id}, '${(item.description || '').replace(/'/g, "\\'")}')">
                            ${item.description || '<span class="text-gray-400 italic">No description</span>'}
                            ${!item.description ? '<button onclick="generateDescription(event, ' + item.id + ')" class="ml-2 text-xs bg-blue-500 text-white px-2 py-1 rounded">Generate</button>' : ''}
                        </div>
                    </td>
                    <td class="p-3 text-sm">${item.category || 'N/A'}</td>
                    <td class="p-3">
                        ${item.tags ? `<div class="flex flex-wrap gap-1">${renderTags(item.tags)}</div>` : '<span class="text-gray-400">No tags</span>'}
                    </td>
                    <td class="p-3 text-sm">${fileSize}</td>
                    <td class="p-3">
                        <div class="action-buttons">
                            <a href="${launchUrl}" target="_blank" class="launch-btn">
                                <i data-lucide="play" class="w-4 h-4"></i>
                            </a>
                            <button onclick="editProject('${item.folder_path}')" class="edit-btn">
                                <i data-lucide="edit" class="w-3 h-3"></i>
                            </button>
                            <button onclick="deleteItem(${item.id})" class="delete-btn">
                                <i data-lucide="trash-2" class="w-3 h-3"></i>
                            </button>
                        </div>
                    </td>
                </tr>
            `;
        }

        function renderTags(tagsStr) {
            if (!tagsStr) return '';
            return tagsStr.split(',').map(tag => `<span class="tag-badge text-xs">${tag.trim()}</span>`).join('');
        }

        function groupItemsByFolder(items) {
            const groups = {};
            items.forEach(item => {
                const folder = item.folder_path || 'Unknown';
                if (!groups[folder]) {
                    groups[folder] = [];
                }
                groups[folder].push(item);
            });
            return groups;
        }

        function toggleFolder(folder) {
            if (collapsedGroups.has(folder)) {
                collapsedGroups.delete(folder);
            } else {
                collapsedGroups.add(folder);
            }
            renderContent();
        }

        function sortTable(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }
            renderContent();
        }

        function handleDateSortChange() {
            dateSort = dateSortSelect.value;
            handleFilterChange();
        }

        function applyDateFilter() {
            dateFrom = dateFromInput.value;
            dateTo = dateToInput.value;
            handleFilterChange();
        }

        function clearDateFilter() {
            dateFrom = '';
            dateTo = '';
            dateFromInput.value = '';
            dateToInput.value = '';
            handleFilterChange();
        }

        function checkDateRangeFilter(item) {
            if (!dateFrom && !dateTo) return true;

            const itemDate = new Date(item.created_at || item.last_modified);
            if (isNaN(itemDate.getTime())) return true; // Skip if no valid date

            const fromDate = dateFrom ? new Date(dateFrom) : null;
            const toDate = dateTo ? new Date(dateTo + 'T23:59:59') : null; // Include the entire day

            if (fromDate && itemDate < fromDate) return false;
            if (toDate && itemDate > toDate) return false;

            return true;
        }

        function applyDateSorting() {
            const sortByDate = (a, b) => {
                let dateA, dateB;

                if (dateSort.includes('created')) {
                    dateA = new Date(a.created_at || 0);
                    dateB = new Date(b.created_at || 0);
                } else if (dateSort.includes('modified')) {
                    dateA = new Date(a.last_modified || 0);
                    dateB = new Date(b.last_modified || 0);
                }

                if (isNaN(dateA.getTime())) dateA = new Date(0);
                if (isNaN(dateB.getTime())) dateB = new Date(0);

                if (dateSort.includes('_desc')) {
                    return dateB - dateA; // Newest first
                } else {
                    return dateA - dateB; // Oldest first
                }
            };

            filteredItems.sort(sortByDate);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
        }

        function editDescription(itemId, currentDescription) {
            event.stopPropagation();
            const cell = event.target.closest('.editable-description');
            const originalHtml = cell.innerHTML;

            cell.innerHTML = `
                <input type="text" class="description-input" value="${currentDescription.replace(/"/g, '"')}" onblur="saveDescription(${itemId}, this.value, '${originalHtml.replace(/"/g, '"')}')" onkeydown="if(event.key === 'Enter') this.blur(); if(event.key === 'Escape') { this.parentElement.innerHTML = '${originalHtml.replace(/"/g, '"')}'; }">
            `;

            cell.querySelector('input').focus();
        }

        function saveDescription(itemId, newDescription, originalHtml) {
            fetch(`/api/update-description/${itemId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ description: newDescription })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Update the item in our local array
                    const item = allItems.find(i => i.id === itemId);
                    if (item) {
                        item.description = newDescription;
                    }
                    renderContent();
                } else {
                    alert('Failed to update description');
                    event.target.closest('.editable-description').innerHTML = originalHtml;
                }
            })
            .catch(error => {
                console.error('Error updating description:', error);
                alert('Error updating description');
                event.target.closest('.editable-description').innerHTML = originalHtml;
            });
        }

        function generateDescription(event, itemId) {
            event.stopPropagation();
            const button = event.target;
            button.disabled = true;
            button.textContent = 'Generating...';

            fetch(`/api/process-llm/${itemId}`, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update the item in our local array
                        const item = allItems.find(i => i.id === itemId);
                        if (item) {
                            item.description = data.data.description;
                            item.category = data.data.category;
                            item.tags = data.data.tags;
                        }
                        renderContent();
                    } else {
                        alert('Failed to generate description');
                        button.disabled = false;
                        button.textContent = 'Generate';
                    }
                })
                .catch(error => {
                    console.error('Error generating description:', error);
                    alert('Error generating description');
                    button.disabled = false;
                    button.textContent = 'Generate';
                });
        }

        function deleteItem(itemId) {
            itemToDelete = itemId;
            domElements.deleteModal.classList.remove('hidden');
        }

        function hideDeleteModal() {
            deleteModal.classList.add('hidden');
            itemToDelete = null;
        }

        function confirmDelete() {
            if (!itemToDelete) return;

            fetch('/remove_item', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ item_id: itemToDelete })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove from local arrays
                    allItems = allItems.filter(item => item.id !== itemToDelete);
                    filteredItems = filteredItems.filter(item => item.id !== itemToDelete);
                    renderContent();
                    updateItemCounter();
                    hideDeleteModal();
                } else {
                    alert('Failed to delete item: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error deleting item:', error);
                alert('Error deleting item');
            });
        }

        function toggleFavourite(itemId) {
            fetch(`/api/toggle-favourite/${itemId}`, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Update the item in our local arrays
                        const updateItem = (item) => {
                            if (item.id === itemId) {
                                item.is_favourite = data.is_favourite;
                            }
                        };
                        allItems.forEach(updateItem);
                        filteredItems.forEach(updateItem);
                        renderContent();
                    } else {
                        alert('Failed to toggle favourite status');
                    }
                })
                .catch(error => {
                    console.error('Error toggling favourite:', error);
                    alert('Error toggling favourite status');
                });
        }

        function fixThumbnails() {
            if (confirm('This will regenerate thumbnails for all items that are missing them. Continue?')) {
                fixThumbnailsBtn.disabled = true;
                fixThumbnailsBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 animate-spin mr-2"></i>Processing...';

                fetch('/api/regenerate-thumbnails', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            alert(`Started regenerating thumbnails for ${data.count} items. Page will refresh when complete.`);
                            // Auto-refresh to show progress
                            setInterval(() => location.reload(), 5000);
                        } else {
                            alert('Failed to start thumbnail regeneration: ' + data.error);
                            fixThumbnailsBtn.disabled = false;
                            fixThumbnailsBtn.innerHTML = '<i data-lucide="image" class="w-4 h-4 mr-2"></i>Fix Thumbnails';
                        }
                    })
                    .catch(error => {
                        console.error('Error fixing thumbnails:', error);
                        alert('Error fixing thumbnails');
                        fixThumbnailsBtn.disabled = false;
                        fixThumbnailsBtn.innerHTML = '<i data-lucide="image" class="w-4 h-4 mr-2"></i>Fix Thumbnails';
                    });
            }
        }

        function editProject(folderPath) {
            fetch('/api/edit-project', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ folder_path: folderPath })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    alert('Project opened in VS Code successfully!');
                } else {
                    alert('Failed to open project in VS Code: ' + (data.error || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error opening project in VS Code:', error);
                alert('Error opening project in VS Code');
            });
        }

        function cleanApps() {
            if (confirm('This will stop all running Python applications and free up RAM. Continue?')) {
                cleanAppsBtn.disabled = true;
                cleanAppsBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 animate-spin mr-2"></i>Cleaning...';

                fetch('/api/clean-apps', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            alert(`Successfully stopped ${data.stopped_count} running applications.`);
                            cleanAppsBtn.disabled = false;
                            cleanAppsBtn.innerHTML = '<span>üßπ</span> <span>Clean Apps</span>';
                        } else {
                            alert('Failed to Stop All started Apps: ' + data.error);
                            cleanAppsBtn.disabled = false;
                            cleanAppsBtn.innerHTML = '<i data-lucide="broom" class="w-4 h-4 mr-2"></i>Stop All started Apps';
                        }
                    })
                    .catch(error => {
                        console.error('Error cleaning apps:', error);
                        alert('Error cleaning apps');
                        cleanAppsBtn.disabled = false;
                        cleanAppsBtn.innerHTML = '<span>üßπ</span> <span>Clean Apps</span>';
                    });
            }
        }

        function purgeDatabase() {
            if (confirm('This will permanently delete ALL data from the database and remove all thumbnails. This action cannot be undone. Continue?')) {
                purgeDatabaseBtn.disabled = true;
                purgeDatabaseBtn.innerHTML = '<i data-lucide="loader" class="w-4 h-4 animate-spin mr-2"></i>Purging...';

                fetch('/api/purge-database', { method: 'POST' })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            alert('Database purged successfully. Page will reload.');
                            location.reload();
                        } else {
                            alert('Failed to purge database: ' + data.error);
                            purgeDatabaseBtn.disabled = false;
                            purgeDatabaseBtn.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4 mr-2"></i>Purge Database';
                        }
                    })
                    .catch(error => {
                        console.error('Error purging database:', error);
                        alert('Error purging database');
                        purgeDatabaseBtn.disabled = false;
                        purgeDatabaseBtn.innerHTML = '<i data-lucide="trash-2" class="w-4 h-4 mr-2"></i>Purge Database';
                    });
            }
        }

        function startThumbnailPolling() {
            if (isPollingActive) return; // Already polling

            isPollingActive = true;
            console.log('Starting selective thumbnail polling...');

            let pollingInterval = 5000; // Start with 5 seconds (increased from 3 seconds)
            let pollingRetryCount = 0;
            const maxRetries = 5;
            let pollingBackoffMultiplier = 1;

            thumbnailUpdateInterval = setInterval(function() {
                // Throttled polling to prevent excessive requests
                if (pollingThrottleTimeout) {
                    console.log(`[${new Date().toISOString()}] Polling throttled, skipping cycle`);
                    return;
                }

                pollingThrottleTimeout = setTimeout(() => {
                    pollingThrottleTimeout = null;
                }, POLLING_THROTTLE_MS);

                const pollStart = performance.now();
                console.log(`[${new Date().toISOString()}] Thumbnail polling cycle start`);
                // POTENTIAL BOTTLENECK: Continuous polling even when no updates needed
                checkForCompletedThumbnails()
                    .then(() => {
                        const pollEnd = performance.now();
                        console.log(`[${new Date().toISOString()}] Thumbnail polling cycle completed in ${(pollEnd - pollStart).toFixed(2)}ms`);
                    })
                    .catch(error => {
                        console.error(`[${new Date().toISOString()}] Error in thumbnail polling:`, error);
                        pollingRetryCount++;

                        if (pollingRetryCount >= maxRetries) {
                            console.error(`[${new Date().toISOString()}] Max retries reached for thumbnail polling, stopping`);
                            stopThumbnailPolling();
                            return;
                        }

                        // Implement backoff: increase interval on errors
                        pollingBackoffMultiplier = Math.min(pollingBackoffMultiplier * 1.5, 10); // Max 10x multiplier
                        const newInterval = pollingInterval * pollingBackoffMultiplier;
                        console.log(`[${new Date().toISOString()}] Backing off thumbnail polling to ${newInterval}ms`);

                        // Clear current interval and restart with new timing
                        clearInterval(thumbnailUpdateInterval);
                        thumbnailUpdateInterval = null;
                        isPollingActive = false;
                        setTimeout(() => startThumbnailPolling(), newInterval);
                    });
            }, pollingInterval);
        }

        function stopThumbnailPolling() {
            if (thumbnailUpdateInterval) {
                clearInterval(thumbnailUpdateInterval);
                thumbnailUpdateInterval = null;
            }
            if (pollingThrottleTimeout) {
                clearTimeout(pollingThrottleTimeout);
                pollingThrottleTimeout = null;
            }
            isPollingActive = false;
            console.log('Stopped thumbnail polling');
        }

        function checkForCompletedThumbnails() {
            const checkStart = performance.now();
            console.log(`[${new Date().toISOString()}] Checking for completed thumbnails`);
            return fetch(`/api/completed-items?since=${encodeURIComponent(lastCompletedCheck)}`)
                .then(response => response.json())
                .then(data => {
                    const fetchEnd = performance.now();
                    console.log(`[${new Date().toISOString()}] Completed thumbnails fetch took ${(fetchEnd - checkStart).toFixed(2)}ms`);
                    if (data.completed_items && data.completed_items.length > 0) {
                        console.log(`[${new Date().toISOString()}] Found ${data.completed_items.length} completed thumbnails`);
                        const updateStart = performance.now();
                        // Use requestAnimationFrame for thumbnail updates
                        requestAnimationFrame(() => {
                            updateThumbnails(data.completed_items);
                            const updateEnd = performance.now();
                            console.log(`[${new Date().toISOString()}] Thumbnail updates took ${(updateEnd - updateStart).toFixed(2)}ms`);
                        });
                        lastCompletedCheck = data.timestamp || new Date().toISOString();
                    } else {
                        console.log(`[${new Date().toISOString()}] No completed thumbnails found`);
                    }
                })
                .catch(error => {
                    console.error(`[${new Date().toISOString()}] Error checking for completed thumbnails:`, error);
                    throw error; // Re-throw to allow caller to handle
                });
        }

        function updateThumbnails(completedItems) {
            console.log(`[${new Date().toISOString()}] Updating ${completedItems.length} thumbnails`);
            // Throttled processing: process in batches to avoid blocking
            const updateStart = performance.now();
            let processed = 0;
            const batchSize = 5; // Process 5 items per batch

            const processBatch = () => {
                const batch = completedItems.slice(processed, processed + batchSize);
                batch.forEach(item => {
                    updateThumbnailForItem(item);
                });
                processed += batch.length;

                if (processed < completedItems.length) {
                    // Schedule next batch asynchronously
                    setTimeout(processBatch, 0);
                } else {
                    const updateEnd = performance.now();
                    console.log(`[${new Date().toISOString()}] All thumbnail updates completed in ${(updateEnd - updateStart).toFixed(2)}ms`);
                }
            };

            processBatch();
        }

        function updateThumbnailForItem(item) {
            const updateStart = performance.now();
            console.log(`[${new Date().toISOString()}] Updating thumbnail for item ${item.id}: ${item.name}`);
            // Find all images that correspond to this item
            const itemId = item.id;
            const newThumbUrl = item.thumb_url;

            // Use cached image elements for efficient updates
            const cachedImages = imageElementCache.get(itemId) || [];
            console.log(`[${new Date().toISOString()}] Found ${cachedImages.length} cached images for item ${itemId}`);
            cachedImages.forEach(img => {
                if (img && img.parentNode) { // Check if element still exists in DOM
                    updateImageWithFade(img, newThumbUrl);
                }
            });

            // Fallback: if no cached images, do a single query (rare case)
            if (cachedImages.length === 0) {
                const images = document.querySelectorAll(`img[data-item-id="${itemId}"]`);
                console.log(`[${new Date().toISOString()}] Fallback: Found ${images.length} images for item ${itemId}`);
                images.forEach(img => {
                    updateImageWithFade(img, newThumbUrl);
                });
            }

            const updateEnd = performance.now();
            console.log(`[${new Date().toISOString()}] Thumbnail update for item ${item.id} completed in ${(updateEnd - updateStart).toFixed(2)}ms`);
        }

        function updateImageWithFade(img, newSrc) {
            const fadeStart = performance.now();
            if (img.src !== newSrc) {
                console.log(`[${new Date().toISOString()}] Updating image src from ${img.src.split('?')[0]} to ${newSrc}`);
                // Add fade-in class for animation
                img.classList.add('fade-in');

                // Update the source
                img.src = newSrc + '?t=' + Date.now(); // Cache busting

                // Remove fade-in class after animation completes
                setTimeout(() => {
                    img.classList.remove('fade-in');
                    const fadeEnd = performance.now();
                    console.log(`[${new Date().toISOString()}] Image fade animation completed in ${(fadeEnd - fadeStart).toFixed(2)}ms`);
                }, 500);
            } else {
                console.log(`[${new Date().toISOString()}] Image src unchanged, skipping update`);
            }
        }

        // Global functions for onclick handlers
        window.toggleFolder = toggleFolder;
        window.editDescription = editDescription;
        window.saveDescription = saveDescription;
        window.generateDescription = generateDescription;
        window.deleteItem = deleteItem;
        window.toggleFavourite = toggleFavourite;
        window.editProject = editProject;
        window.cleanApps = cleanApps;

        // Optimized placeholder image update function
        function updatePlaceholderImages() {
            const imgStart = performance.now();
            // Use cached placeholder images instead of querying all images
            let placeholderCount = 0;
            imageElementCache.forEach((images, itemId) => {
                images.forEach(img => {
                    if (img && img.parentNode && img.src.includes('placeholder.png')) {
                        placeholderCount++;
                        // Add timestamp to force reload of placeholders
                        img.src = img.src.split('?')[0] + '?t=' + Date.now();
                    }
                });
            });
            const imgEnd = performance.now();
            console.log(`[${new Date().toISOString()}] Optimized placeholder image refresh: ${placeholderCount} placeholders updated, took ${(imgEnd - imgStart).toFixed(2)}ms`);
        }
    </script>
</body>
</html>
